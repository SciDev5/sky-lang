/*
PARSPEC


let a = 4 + 3

h { f -> }



*/

use std::{collections::HashMap, fmt::Debug, vec};

use num::complex::Complex64;

use crate::{
    common::{common_module::DocComment, IdentStr},
    math::shunting_yard::{treeify_infix, ShuntingYardObj},
};

use super::{
    ast::{
        ASTAnonymousFunction, ASTBlock, ASTBlockStructInit, ASTCompoundPostfixContents,
        ASTExpression, ASTFunctionDefinition, ASTLiteral, ASTOptionallyTypedIdent, ASTTypedIdent,
        ASTVarAccessExpression,
    },
    ops::SLOperator,
    raw_module::{RMTemplateDef, RMType},
    tokenization::{BracketType, Keyword, SLSymbol, SLToken, SeparatorType},
};

macro_rules! parse_first {
    (ENTRY $tokens: ident; $parser: ident) => {
        $tokens. $parser ()
    };
    (ENTRY $tokens: ident; $parser: ident; $($paramv: expr),*) => {
        $tokens. $parser ($($paramv),*)
    };
    ($tokens: ident; $($parser: ident $(($($paramv: expr),* $(,)?))? => |$param: ident| $success_transform: expr ),+ $(,)?) => {
        $(
            if let Some($param) = parse_first!(ENTRY $tokens; $parser $( ; $($paramv),* )?) {
                Some({
                    $success_transform
                })
            } else
        )+ {
            None
        }
    };
}

/// The result of parsing a section of tokens.
///
/// The error is a bool, indicating if the error is recoverable.
type ParseResult<T> = Result<T, bool>;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseDiagnostic {
    UnexpectedEnd,
    ExpectedKeyword(Keyword),
    ExpectedSymbol(SLSymbol),
    ExpectedSeparator(SeparatorType),
    ExpectedExpr,
    ExpectedIdentifier,
    ExpectedBracketOpen(BracketType),
    ExpectedBracketClose(BracketType),
    ExpectedFunctionBody,
    ExpectedTypeAnnotation,
    UnexpectedExtraCallbackArgument,
    DuplicateFunctions,
    ExpectedStructFunctions,
}

#[derive(Debug)]
pub struct Tokens<'a, 'token_content> {
    require_soft_break: bool,
    prev_index: usize,
    index: usize,
    tokens: &'a [SLToken<'token_content>],
    diagnostics: Vec<ParseDiagnostic>,
}

impl<'a, 'token_content> Tokens<'a, 'token_content> {
    fn new(tokens: &'a [SLToken<'token_content>]) -> Self {
        Self {
            require_soft_break: false,
            prev_index: 0,
            index: 0,
            tokens,
            diagnostics: vec![],
        }
    }

    /*

    Parser token iteration:

    "try_...": Attempt to parse something, else rewind.
        Some(parsed value) -> pointer += matched length
        None -> pointer unchanged

    "..." (parse functions not starting with `try_`): Parse something or fail.
        Ok(parsed value) -> pointer += matched length
        Err(recoverable = true) -> pointer += successfully matched tokens, can recover if value not needed
            generated by matching unexpected tokens without messing up the general structure
        Err(recoverable = false) -> indicates must return and propagate this error up
            generated by bracket mismatch or unexpected end of file which both disturb the program structure
    */

    ///////////////////////////////////////////////////////////////////////////
    // Utility functions that match the next token.
    //

    /// Match the next token (including spaces), returning None if the end is hit.
    fn try_next_or_whitespace(&mut self) -> Option<&'a SLToken<'token_content>> {
        if self.take_require_soft_break() {
            panic!("improper use of require_soft_break");
        }

        let prev_index = self.prev_index;
        let out = if self.index < self.tokens.len() {
            self.index += 1;
            Some(&self.tokens[self.index - 1])
        } else {
            None
        };
        self.prev_index = prev_index;
        out
    }
    #[inline(always)]
    fn require_soft_break(&mut self) -> &mut Self {
        self.require_soft_break = true;
        self
    }
    fn take_require_soft_break(&mut self) -> bool {
        let require_soft_break = self.require_soft_break;
        self.require_soft_break = false;
        require_soft_break
    }
    /// Match the next token (not including spaces), returning None if the end is hit.
    fn try_next(&mut self) -> Option<&'a SLToken<'token_content>> {
        let require_soft_break = self.take_require_soft_break();

        let prev_index = self.index;
        let out = if self.index < self.tokens.len() {
            loop {
                match {
                    if self.index < self.tokens.len() {
                        self.index += 1;
                        Some(&self.tokens[self.index - 1])
                    } else {
                        None
                    }
                } {
                    Some(SLToken::Space { hard }) => {
                        if require_soft_break && *hard {
                            return None;
                        } else {
                            continue;
                        }
                    }
                    Some(SLToken::Comment { documenting, .. }) => {
                        continue;
                    }
                    token => {
                        self.prev_index = prev_index;
                        return token;
                    }
                }
            }
        } else {
            None
        };
        self.prev_index = prev_index;
        out
    }

    /// Match the next token (not including spaces), returning Err if the end is hit.
    fn next(&mut self) -> ParseResult<&'a SLToken<'token_content>> {
        match self.try_next() {
            Some(v) => Ok(v),
            None => {
                self.diagnostics.push(ParseDiagnostic::UnexpectedEnd);
                Err(false)
            }
        }
    }
    /// Peek the next token (not including spaces), returning None if the end is hit.
    fn peek_next(&mut self) -> Option<&'a SLToken<'token_content>> {
        let require_soft_break = self.take_require_soft_break();

        let mut index = self.index;

        let out = if index < self.tokens.len() {
            loop {
                match {
                    if index < self.tokens.len() {
                        index += 1;
                        Some(&self.tokens[index - 1])
                    } else {
                        None
                    }
                } {
                    Some(SLToken::Space { hard }) => {
                        if require_soft_break && *hard {
                            return None;
                        } else {
                            continue;
                        }
                    }
                    Some(SLToken::Comment { .. }) => {
                        continue;
                    }
                    token => return token,
                }
            }
        } else {
            None
        };
        out
    }
    /// Peek the previous token (not including spaces), returning None if the start is hit.
    fn peek_prev(&mut self) -> Option<&'a SLToken<'token_content>> {
        let require_soft_break = self.take_require_soft_break();

        let mut index = self.index;

        let out = if index < self.tokens.len() {
            loop {
                match {
                    if index > 0 {
                        index -= 1;
                        Some(&self.tokens[index + 1])
                    } else {
                        None
                    }
                } {
                    Some(SLToken::Space { hard }) => {
                        if require_soft_break && *hard {
                            return None;
                        } else {
                            continue;
                        }
                    }
                    Some(SLToken::Comment { .. }) => {
                        continue;
                    }
                    token => return token,
                }
            }
        } else {
            None
        };
        out
    }

    fn rewind(&mut self) {
        self.index = self.prev_index;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Utility functions that match groups of tokens.
    //

    #[inline(always)]
    fn parse_optional_result<
        T,
        I,
        F1: FnOnce(&mut Self) -> Option<I>,
        F2: FnOnce(&mut Self, I) -> ParseResult<T>,
    >(
        &mut self,
        cb1: F1,
        cb2: F2,
    ) -> Option<ParseResult<T>> {
        let revert = self.get_state();
        if let Some(intermediate) = cb1(self) {
            Some(cb2(self, intermediate))
        } else {
            self.revert_state(revert);
            None
        }
    }

    fn get_state(&mut self) -> (usize, usize) {
        (self.prev_index, self.index)
    }
    fn revert_state(&mut self, (prev_index, index): (usize, usize)) {
        self.index = index;
        self.prev_index = prev_index;
        self.require_soft_break = false;
    }

    #[inline(always)]
    fn lookahead<T, F: FnOnce(&mut Self) -> Option<T>>(&mut self, cb: F) -> Option<T> {
        let revert = self.get_state();
        let res = cb(self);
        self.revert_state(revert);
        res
    }

    #[inline(always)]
    fn parse_optional<T, F: FnOnce(&mut Self) -> Option<T>>(&mut self, cb: F) -> Option<T> {
        let revert = self.get_state();
        let res = cb(self);
        if res.is_none() {
            self.revert_state(revert);
        }
        res
    }

    fn try_else_discard_diagnostics<T, F: Fn(&mut Self) -> ParseResult<T>>(
        &mut self,
        cb: F,
    ) -> Option<T> {
        let revert = self.get_state();
        let revert_diagnostic_len = self.diagnostics.len();
        let res = cb(self);
        if res.is_err() {
            self.revert_state(revert);
            self.diagnostics.drain(revert_diagnostic_len..);
        }
        res.ok()
    }

    fn parse_until<T: Debug, F: Fn(&mut Self) -> ParseResult<T>>(
        &mut self,
        parse: F,
        separator: SLToken<'static>,
        terminator: SLToken<'static>,
        separator_missing_diagnostic: ParseDiagnostic,
    ) -> ParseResult<Vec<T>> {
        let mut output = vec![];
        if self.peek_next() == Some(&terminator) {
            self.next()?;
            return Ok(output);
        }
        'outer: loop {
            match parse(self) {
                Ok(v) => {
                    output.push(v);

                    match self.next()? {
                        token if token == &separator => {
                            if self.peek_next() == Some(&terminator) {
                                self.next()?;
                                break 'outer;
                            }
                        }
                        token if token == &terminator => {
                            break 'outer;
                        }
                        _ => {
                            self.diagnostics.push(separator_missing_diagnostic);
                            // skip until we find a separator or terminator
                            loop {
                                let next = self.next()?;
                                if next == &separator {
                                    if self.peek_next() == Some(&terminator) {
                                        self.next()?;
                                        break 'outer;
                                    }
                                    continue 'outer;
                                }
                                if next == &terminator {
                                    break 'outer;
                                }
                            }
                        }
                    }
                }
                Err(recoverable) => {
                    if !recoverable {
                        return Err(false);
                    }
                    loop {
                        let next = self.next()?;
                        if next == &separator {
                            if self.peek_next() == Some(&terminator) {
                                self.next()?;
                                break 'outer;
                            }
                            continue 'outer;
                        }
                        if next == &terminator {
                            break 'outer;
                        }
                    }
                }
            }
        }
        Ok(output)
    }

    ///////////////////////////////////////////////////////////////////////////
    // Utility functions that match simple tokens.
    //

    fn try_doc_comment(&mut self) -> Option<String> {
        self.parse_optional(|t| loop {
            match t.try_next_or_whitespace()? {
                SLToken::Space { .. } => continue,
                SLToken::Comment {
                    content,
                    documenting,
                } => {
                    if *documenting {
                        break Some(content.to_string());
                    } else {
                        continue;
                    }
                }
                _ => break None,
            }
        })
    }

    fn try_keyword(&mut self, keyword: Keyword) -> Option<()> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Keyword(matched_keyword) if *matched_keyword == keyword => Some(()),
            _ => None,
        })
    }
    fn try_any_keyword(&mut self) -> Option<Keyword> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Keyword(keyword) => Some(*keyword),
            _ => None,
        })
    }
    fn keyword(&mut self, keyword: Keyword) -> ParseResult<()> {
        match self.next()? {
            SLToken::Keyword(matched_keyword) if *matched_keyword == keyword => Ok(()),
            _ => {
                self.rewind();
                self.diagnostics
                    .push(ParseDiagnostic::ExpectedKeyword(keyword));
                Err(true)
            }
        }
    }

    fn try_symbol(&mut self, symbol: SLSymbol) -> Option<()> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Symbol(matched_symbol) if *matched_symbol == symbol => Some(()),
            _ => None,
        })
    }
    fn try_any_symbol(&mut self) -> Option<SLSymbol> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Symbol(symbol) => Some(*symbol),
            _ => None,
        })
    }
    fn symbol(&mut self, symbol: SLSymbol) -> ParseResult<()> {
        match self.next()? {
            SLToken::Symbol(matched_symbol) if *matched_symbol == symbol => Ok(()),
            _ => {
                self.rewind();
                self.diagnostics
                    .push(ParseDiagnostic::ExpectedSymbol(symbol));
                Err(true)
            }
        }
    }

    fn try_separator(&mut self, separator: SeparatorType) -> Option<()> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Separator(matched_separator) if *matched_separator == separator => Some(()),
            _ => None,
        })
    }
    fn separator(&mut self, separator: SeparatorType) -> ParseResult<()> {
        match self.next()? {
            SLToken::Separator(matched_separator) if *matched_separator == separator => Ok(()),
            _ => {
                self.rewind();
                self.diagnostics
                    .push(ParseDiagnostic::ExpectedSeparator(separator));
                Err(true)
            }
        }
    }
    fn try_any_separator(&mut self) -> Option<SeparatorType> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Separator(separator) => Some(*separator),
            _ => None,
        })
    }

    fn try_ident(&mut self) -> Option<IdentStr> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Identifier(ident) => Some(ident.to_string()),
            _ => None,
        })
    }
    fn ident(&mut self) -> ParseResult<IdentStr> {
        match self.next()? {
            SLToken::Identifier(ident) => Ok(ident.to_string()),
            _ => {
                self.rewind();
                self.diagnostics.push(ParseDiagnostic::ExpectedIdentifier);
                Err(true)
            }
        }
    }

    fn try_any_bracket_open(&mut self) -> Option<BracketType> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::BracketOpen(bracket_type) => Some(*bracket_type),
            _ => None,
        })
    }
    fn try_bracket_open(&mut self, bracket_type: BracketType) -> Option<()> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::BracketOpen(matched_bracket) if *matched_bracket == bracket_type => Some(()),
            _ => None,
        })
    }
    fn try_bracket_close(&mut self, bracket_type: BracketType) -> Option<()> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::BracketClose(matched_bracket) if *matched_bracket == bracket_type => Some(()),
            _ => None,
        })
    }
    fn bracket_close(&mut self, bracket_type: BracketType) -> ParseResult<()> {
        match self.next()? {
            SLToken::BracketClose(matched_bracket) if *matched_bracket == bracket_type => Ok(()),
            _ => {
                self.rewind();
                self.diagnostics
                    .push(ParseDiagnostic::ExpectedBracketClose(bracket_type));
                Err(true)
            }
        }
    }
    fn bracket_open(&mut self, bracket_type: BracketType) -> ParseResult<()> {
        match self.next()? {
            SLToken::BracketOpen(matched_bracket) if *matched_bracket == bracket_type => Ok(()),
            _ => {
                self.rewind();
                self.diagnostics
                    .push(ParseDiagnostic::ExpectedBracketOpen(bracket_type));
                Err(true)
            }
        }
    }

    fn try_literal(&mut self) -> Option<ASTLiteral> {
        self.parse_optional(|t| match t.try_next()? {
            SLToken::Float {
                value,
                imaginary: false,
            } => Some(ASTLiteral::Float(*value)),
            SLToken::Float {
                value,
                imaginary: true,
            } => Some(ASTLiteral::Complex(Complex64::new(0.0, *value))),
            SLToken::Int {
                value,
                imaginary: false,
            } => Some(ASTLiteral::Int(*value)),
            SLToken::Int {
                value,
                imaginary: true,
            } => Some(ASTLiteral::Complex(Complex64::new(0.0, *value as f64))),
            SLToken::Bool(value) => Some(ASTLiteral::Bool(*value)),
            // TODO strings
            _ => None,
        })
    }

    ///////////////////////////////////////////////////////////////////////////
    // AST generation
    //

    /// parses a code block, ending at EOF or close curly brace, depending on if it's the top level.
    ///
    /// NOTE(TOP_LEVEL=false): **Doesn't** match initiating curly brace, but **does** match closing curly brace.
    fn parse_block<const TOP_LEVEL: bool>(&mut self) -> ParseResult<ASTBlock> {
        let mut out = vec![];

        loop {
            if TOP_LEVEL {
                if self.peek_next().is_none() {
                    break;
                    // reached end
                }
            } else {
                if self.try_bracket_close(BracketType::Curly).is_some() {
                    break;
                    // reached end
                }
                if self.peek_next().is_none() {
                    self.diagnostics.push(ParseDiagnostic::UnexpectedEnd);
                    return Err(false);
                }
            }
            let expr = match self.parse_expr::</* disallow range literals */false, /* allow block postfixes */true>()
            {
                Ok(v) => v,
                Err(recoverable) => {
                    if recoverable {
                        continue;
                    } else {
                        return Err(false);
                    }
                }
            };
            out.push(expr);
        }

        Ok(out)
    }
    /// Parses a code block surrounded by curly braces.
    ///
    /// `{ $($expr)* }`
    fn parse_curly_block(&mut self) -> ParseResult<ASTBlock> {
        self.bracket_open(BracketType::Curly)?;
        let block = self.parse_block::</* not top level */false>();
        block
    }

    fn parse_expr<const ALLOW_RANGE_LITERAL: bool, const ALLOW_BLOCK_POSTFIX: bool>(
        &mut self,
    ) -> ParseResult<ASTExpression> {
        if ALLOW_RANGE_LITERAL {
            // ranges go `start? : step : end?` or `start? : end?`
            if self.try_separator(SeparatorType::Colon).is_some() {
                // `: expr_0 ...`, range with no start bound
                let expr_0 = self.parse_expr::<false, ALLOW_BLOCK_POSTFIX>()?;
                if self.try_separator(SeparatorType::Colon).is_some() {
                    // `: expr_0 : expr_1`, range with end bound, and stride
                    let expr_1 = self.parse_expr::<false, ALLOW_BLOCK_POSTFIX>()?;
                    Ok(ASTExpression::Range {
                        start: None,
                        step: Some(Box::new(expr_0)),
                        end: Some(Box::new(expr_1)),
                    })
                } else {
                    // `: expr_0 :`, range with stride only
                    Ok(ASTExpression::Range {
                        start: None,
                        step: Some(Box::new(expr_0)),
                        end: None,
                    })
                }
            } else {
                let expr_0 = self.parse_expr::<false, ALLOW_BLOCK_POSTFIX>()?;
                if self.try_separator(SeparatorType::Colon).is_some() {
                    // `expr_0 : expr_1 ...`, range with start bound
                    let expr_1 = self.parse_expr::<false, ALLOW_BLOCK_POSTFIX>()?;
                    if self.try_separator(SeparatorType::Colon).is_some() {
                        // `expr_0 : expr_1 : expr_2`, range with start, end, and stride
                        let expr_2 = self.parse_expr::<false, ALLOW_BLOCK_POSTFIX>()?;
                        Ok(ASTExpression::Range {
                            start: Some(Box::new(expr_0)),
                            step: Some(Box::new(expr_1)),
                            end: Some(Box::new(expr_2)),
                        })
                    } else {
                        // `expr_0 : expr_1`, range with start and end bounds
                        Ok(ASTExpression::Range {
                            start: Some(Box::new(expr_0)),
                            step: None,
                            end: Some(Box::new(expr_1)),
                        })
                    }
                } else {
                    // simple expression
                    Ok(expr_0)
                }
            }
        } else {
            self.parse_expr_allow_infix::<ALLOW_BLOCK_POSTFIX>()
        }
    }

    fn parse_expr_allow_infix<const ALLOW_BLOCK_POSTFIX: bool>(
        &mut self,
    ) -> ParseResult<ASTExpression> {
        let first_expr = self.parse_expr_no_infix::<ALLOW_BLOCK_POSTFIX>()?;

        let mut as_infix = vec![ShuntingYardObj::Expr(first_expr)];
        while let Some(op) = self.parse_optional(|t| {
            let op = t.try_any_symbol()?.to_operator()?;
            if op.is_infix() {
                Some(op)
            } else {
                None
            }
        }) {
            let expr = self.parse_expr_no_infix::<ALLOW_BLOCK_POSTFIX>()?;
            as_infix.push(ShuntingYardObj::Op(op));
            as_infix.push(ShuntingYardObj::Expr(expr));
        }

        Ok(treeify_infix(&mut as_infix.into_iter(), &|op, a, b| {
            ASTExpression::BinaryOp {
                op,
                lhs: Box::new(a),
                rhs: Box::new(b),
            }
        }))
    }

    fn parse_expr_no_infix<const ALLOW_BLOCK_POSTFIX: bool>(
        &mut self,
    ) -> ParseResult<ASTExpression> {
        let prefixes = std::iter::from_fn(|| self.try_parse_expr_prefix()).collect::<Vec<_>>();

        let mut expr = match parse_first!(self;



            // -- literals -- //
            try_parse_anonfunc => |func| ASTExpression::AnonymousFunction(func?),
            try_literal => |literal| ASTExpression::Literal(literal),
            // TODO array/tensor/matrix literals

            // -- local variables -- //
            try_parse_var_declare_expr => |expr| expr?,
            try_parse_var_assign_expr => |expr| expr?,

            // -- identifiers -- //
            try_ident => |ident| ASTExpression::Ident(ident),


            // -- control flow -- //
            try_parse_conditional => |expr| expr?,
            try_parse_infinite_loop => |expr| expr?,
            try_parse_for => |expr| expr?,
            try_parse_while => |expr| expr?,
            try_parse_control_word => |expr| expr,

            // -- grouping -- //
            try_parse_expr_parentheses => |expr| expr?,

            // -- static definitions -- //
            try_parse_top_level_function_declaration => |it| it?,
            try_parse_static_trait_declaration => |it| it?,
            try_parse_static_struct_declaration => |it| it?,

        ) {
            Some(v) => v,
            None => {
                self.diagnostics.push(ParseDiagnostic::ExpectedExpr);
                self.try_next_or_whitespace(); // advance to restart parsing on the next token
                return Err(true);
            }
        };

        let postfixes = std::iter::from_fn(|| self.try_parse_expr_postfix::<ALLOW_BLOCK_POSTFIX>())
            .collect::<Vec<_>>();

        for affix in postfixes.into_iter().chain(prefixes.into_iter().rev()) {
            expr = match affix {
                Ok(ExprAffix::Op(op)) => ASTExpression::UnaryOp {
                    op,
                    value: Box::new(expr),
                },
                Ok(ExprAffix::Compound(contents)) => ASTExpression::CompoundPostfix {
                    target: Box::new(expr),
                    contents,
                },
                Err(recoverable) => {
                    return Err(recoverable);
                }
            }
        }

        Ok(expr)
    }

    fn try_parse_expr_prefix(&mut self) -> Option<ParseResult<ExprAffix>> {
        if let Some(op) = self.parse_optional(|t| {
            let op = t.try_any_symbol()?.to_operator()?;
            if op.is_prefix() {
                Some(op)
            } else {
                None
            }
        }) {
            Some(Ok(ExprAffix::Op(op)))
        } else {
            None
        }
    }
    fn try_parse_expr_postfix<const ALLOW_BLOCK_POSTFIX: bool>(
        &mut self,
    ) -> Option<ParseResult<ExprAffix>> {
        if let Some(op) = self.parse_optional(|t| {
            // parsing postfix operators //
            let op = t.try_any_symbol()?.to_operator()?;
            if op.is_postfix() {
                Some(op)
            } else {
                None
            }
        }) {
            Some(Ok(ExprAffix::Op(op)))
        } else if self.try_symbol(SLSymbol::PropertyAccess).is_some() {
            Some(Ok(ExprAffix::Compound(
                if self.try_bracket_open(BracketType::Curly).is_some() {
                    // `target.{ ... }` struct data init //
                    let contents = match self.finish_parse_block_struct_init() {
                        Ok(v) => v,
                        Err(recoverable) => return Some(Err(recoverable)),
                    };

                    ASTCompoundPostfixContents::BlockStructInit(contents)
                } else if self.try_bracket_open(BracketType::Paren).is_some() {
                    // `target.( ... )` tuple struct data init //
                    let args = match self.parse_until(
                        Self::parse_expr::<true, true>,
                        SLToken::Separator(SeparatorType::Comma),
                        SLToken::BracketClose(BracketType::Paren),
                        ParseDiagnostic::ExpectedSeparator(SeparatorType::Comma),
                    ) {
                        Ok(v) => v,
                        Err(recoverable) => return Some(Err(recoverable)),
                    };
                    ASTCompoundPostfixContents::TupleStructInit(args)
                } else if let Some(ident) = self.try_ident() {
                    // `target.property` property accesses //

                    ASTCompoundPostfixContents::PropertyAccess(ident)
                } else {
                    // undo reading the dot
                    self.rewind();
                    return None;
                },
            )))
        } else if let Some(bracket_type) = self.try_any_bracket_open() {
            Some(Ok(ExprAffix::Compound(match bracket_type {
                BracketType::Square => {
                    // `target[index_0, ...]` indexing //
                    let indices = match self.parse_until(
                        Self::parse_expr::<true, true>,
                        SLToken::Separator(SeparatorType::Comma),
                        SLToken::BracketClose(BracketType::Square),
                        ParseDiagnostic::ExpectedSeparator(SeparatorType::Comma),
                    ) {
                        Ok(v) => v,
                        Err(recoverable) => return Some(Err(recoverable)),
                    };
                    ASTCompoundPostfixContents::Index(indices)
                }
                BracketType::Angle => unreachable!(),
                BracketType::Paren => {
                    // `target( ... )` function calls //
                    let args = match self.parse_until(
                        Self::parse_expr::<true, true>,
                        SLToken::Separator(SeparatorType::Comma),
                        SLToken::BracketClose(BracketType::Paren),
                        ParseDiagnostic::ExpectedSeparator(SeparatorType::Comma),
                    ) {
                        Ok(v) => v,
                        Err(recoverable) => return Some(Err(recoverable)),
                    };
                    let callback_block = if ALLOW_BLOCK_POSTFIX {
                        match self.parse_optional_result(
                            |t| t.try_bracket_open(BracketType::Curly),
                            |t, _| t.finish_parse_anonfunc(),
                        ) {
                            Some(Ok(cb)) => Some(cb),
                            Some(Err(recoverable)) => {
                                if recoverable {
                                    None
                                } else {
                                    return Some(Err(false));
                                }
                            }
                            None => None,
                        }
                    } else {
                        None
                    };

                    // Multiple consecutive callback blocks are not allowed
                    if ALLOW_BLOCK_POSTFIX {
                        match self.consume_illegal_postfix_blocks() {
                            Ok(_) => {}
                            Err(recoverable) => {
                                if recoverable {
                                    // pass
                                } else {
                                    return Some(Err(false));
                                }
                            }
                        }
                    }

                    ASTCompoundPostfixContents::Call(args, callback_block)
                }
                BracketType::Curly => {
                    // `target{ ... }` callback function shorthand //
                    if !ALLOW_BLOCK_POSTFIX {
                        self.rewind();
                        return None;
                    }
                    let cb_expr = match self.finish_parse_anonfunc() {
                        Ok(v) => v,
                        Err(recoverable) => return Some(Err(recoverable)),
                    };

                    // Multiple consecutive callback blocks are not allowed
                    if ALLOW_BLOCK_POSTFIX {
                        match self.consume_illegal_postfix_blocks() {
                            Ok(_) => {}
                            Err(recoverable) => {
                                if recoverable {
                                    // pass
                                } else {
                                    return Some(Err(false));
                                }
                            }
                        }
                    }

                    ASTCompoundPostfixContents::Call(vec![], Some(cb_expr))
                }
            })))
        } else {
            None
        }
    }

    fn consume_illegal_postfix_blocks(&mut self) -> ParseResult<()> {
        while let Some(k) = self.try_parse_anonfunc() {
            self.diagnostics
                .push(ParseDiagnostic::UnexpectedExtraCallbackArgument);
            k?;
        }
        Ok(())
    }

    fn parse_condition_expr(&mut self) -> ParseResult<ASTExpression> {
        self.parse_expr::<
            /* allow range literal (even if it won't get used, it's not going to cause problems) */true,
            /* disallow block postfix, those will cause problems */false,
        >()
    }
    fn try_parse_conditional(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| {
                // if ...
                t.try_keyword(Keyword::ConditionalIf)
            },
            |t, _| {
                // ... $condition { $block } ...
                let condition = Box::new(t.parse_condition_expr()?);
                let block = t.parse_curly_block()?;

                let mut elifs = vec![];
                // ... $( else if $condition { $block } )* ...
                while let Some(elif) = t.parse_optional_result(
                    |t| {
                        t.try_keyword(Keyword::ConditionalElse)?;
                        t.try_keyword(Keyword::ConditionalIf)
                    },
                    |t, _| {
                        let condition = t.parse_condition_expr()?;
                        let block = t.parse_curly_block()?;

                        Ok((condition, block))
                    },
                ) {
                    match elif {
                        Ok(elif) => elifs.push(elif),
                        Err(recoverable) => {
                            if recoverable {
                                let _ = t.try_keyword(Keyword::ConditionalElse); // step forward to avoid infinite looping
                                let _ = t.try_keyword(Keyword::ConditionalIf); // step forward to avoid infinite looping
                                break;
                            } else {
                                return Err(false);
                            }
                        }
                    }
                }

                // ... $( else { $block} )?
                let else_block = if let Some(else_block) = t.parse_optional_result(
                    |t| t.try_keyword(Keyword::ConditionalElse),
                    |t, _| t.parse_curly_block(),
                ) {
                    match else_block {
                        Ok(else_block) => Some(else_block),
                        Err(recoverable) => {
                            if recoverable {
                                None
                            } else {
                                return Err(false);
                            }
                        }
                    }
                } else {
                    None
                };

                Ok(ASTExpression::Conditional {
                    condition,
                    block,
                    elifs,
                    else_block,
                })
            },
        )
    }
    fn try_parse_infinite_loop(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| {
                // loop ...
                t.try_keyword(Keyword::LoopForever)
            },
            |t, _| {
                // ... { $block }
                let block = t.parse_curly_block()?;

                Ok(ASTExpression::Loop { block })
            },
        )
    }
    fn try_parse_for(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| t.try_keyword(Keyword::LoopFor),
            |t, _| todo!("// TODO try_parse_for"),
        )
    }
    fn try_parse_while(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| {
                // while ...
                t.try_keyword(Keyword::LoopWhile)
            },
            |t, _| {
                // ... $condition { $block }
                let condition = Box::new(t.parse_condition_expr()?);
                let block = t.parse_curly_block()?;

                let else_block = match t.parse_optional_result(
                    |t| t.try_keyword(Keyword::ConditionalElse),
                    |t, _| t.parse_curly_block(),
                ) {
                    Some(else_block) => Some(else_block?),
                    None => None,
                };

                Ok(ASTExpression::LoopWhile {
                    condition,
                    block,
                    else_block,
                })
            },
        )
    }
    fn try_parse_control_word(&mut self) -> Option<ASTExpression> {
        self.parse_optional(|t| {
            Some(match t.try_any_keyword()? {
                Keyword::LoopContinue => ASTExpression::Continue,
                Keyword::LoopBreak => ASTExpression::Break(t.require_soft_break().try_else_discard_diagnostics(|t| {
                    Ok(Box::new(t.parse_expr::</* allow range literal */true, /* allow block postfix */true>()?))
                })),
                Keyword::Return => ASTExpression::Return(t.require_soft_break().try_else_discard_diagnostics(|t| {
                    Ok(Box::new(t.parse_expr::</* allow range literal */true, /* allow block postfix */true>()?))
                })),
                _ => return None
            })
        })
    }

    /// Parse the rest of the block struct initialization thing, beginning after the open curly braces.
    ///
    /// `target.{ <call here> ... }`
    fn finish_parse_block_struct_init(&mut self) -> ParseResult<ASTBlockStructInit> {
        let mut properties = vec![];
        while let Some(v) = self.parse_optional_result(
            |t| {
                // skip commas
                while let Some(_) = t.try_separator(SeparatorType::Comma) {}

                let ident = t.try_ident()?;
                Some(ident)
            },
            |t, ident| {
                let expr = if t.try_separator(SeparatorType::Colon).is_some() {
                    t.parse_expr::</* no range postfix */false, /* allow block postfix */true>()?
                } else {
                    ASTExpression::Ident(ident.clone())
                };
                Ok((ident, expr))
            },
        ) {
            let (ident, expr) = match v {
                Ok(v) => v,
                Err(recoverable) => {
                    if recoverable {
                        continue;
                    } else {
                        return Err(false);
                    }
                }
            };

            properties.push((ident, expr));
        }

        // skip commas
        while let Some(_) = self.try_separator(SeparatorType::Comma) {}
        {
            // skip until next closing bracket
            let needed_skips = !matches!(self.peek_next(), Some(SLToken::BracketClose(_)));
            while !matches!(self.peek_next(), Some(SLToken::BracketClose(_))) {
                self.next()?;
            }
            if needed_skips {
                self.diagnostics
                    .push(ParseDiagnostic::ExpectedBracketClose(BracketType::Curly));
            }
        }
        // cannot recover from missing closing parentheses
        self.bracket_close(BracketType::Curly)
            .map_err(|_recoverable| false)?;

        Ok(ASTBlockStructInit { properties })
    }

    fn try_parse_expr_parentheses(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| {
                // positive match if we see open parentheses
                t.try_bracket_open(BracketType::Paren)
            },
            |t, _| {
                // `... expr )`
                let expr = match t.parse_expr::<true, true>() {
                    Ok(v) => v,
                    Err(recoverable) => {
                        if recoverable {
                            // skip until the next closing grouping symbol
                            while !matches!(t.peek_next(), Some(SLToken::BracketClose(_))) {
                                t.next()?;
                            }
                            // recoverable only if we match a closing parentheses
                            return Err(match t.bracket_close(BracketType::Paren) {
                                Ok(_) => true,
                                Err(_) => false,
                            });
                        } else {
                            return Err(false);
                        }
                    }
                };
                {
                    // skip until next closing bracket
                    let needed_skips = !matches!(t.peek_next(), Some(SLToken::BracketClose(_)));
                    while !matches!(t.peek_next(), Some(SLToken::BracketClose(_))) {
                        t.next()?;
                    }
                    if needed_skips {
                        t.diagnostics
                            .push(ParseDiagnostic::ExpectedBracketClose(BracketType::Paren));
                    }
                }
                // cannot recover from missing closing parentheses
                t.bracket_close(BracketType::Paren)
                    .map_err(|_recoverable| false)?;
                Ok(expr)
            },
        )
    }

    fn try_parse_anonfunc(&mut self) -> Option<ParseResult<ASTAnonymousFunction>> {
        self.try_bracket_open(BracketType::Curly)?;
        Some(self.finish_parse_anonfunc())
    }
    /// parses anonymous functions after the initiating curly paren.
    /// `{ <call it here> arg_1, arg_2, ... -> ... }`
    fn finish_parse_anonfunc(&mut self) -> ParseResult<ASTAnonymousFunction> {
        let params = if self.lookahead_looks_like_anon_func_params() {
            Some(self.parse_until(
                Self::parse_ident_optionally_typed,
                SLToken::Separator(SeparatorType::Comma),
                SLToken::Separator(SeparatorType::ThinArrowRight),
                ParseDiagnostic::ExpectedSeparator(SeparatorType::Comma),
            )?)
        } else {
            None
        };

        let block = self.parse_block::</* not top-level block */false>()?;

        Ok(ASTAnonymousFunction { params, block })
    }
    /// Helper function that returns true if the upcoming token sequence is definitely
    /// the parameter names for an anonymous function.
    fn lookahead_looks_like_anon_func_params(&mut self) -> bool {
        self.lookahead(|t| {
            Some(loop {
                match t.try_next()? {
                    SLToken::Separator(SeparatorType::ThinArrowRight) => break true,
                    SLToken::Identifier(_) => match t.try_next()? {
                        SLToken::Separator(SeparatorType::Comma) => continue,
                        SLToken::Separator(SeparatorType::Colon) => break true,
                        SLToken::Separator(SeparatorType::ThinArrowRight) => break true,
                        _ => break false,
                    },
                    _ => break false,
                }
            })
        })
        .unwrap_or(false)
    }

    fn try_parse_type_ident(&mut self) -> Option<RMType> {
        let ident = self.try_ident()?;

        Some(match ident.as_str() {
            "bool" => RMType::Bool,
            "int" => RMType::Int,
            "float" => RMType::Float,
            "complex" => RMType::Complex,
            "string" => RMType::String,
            _ => RMType::Identified(ident),
        })
    }
    fn try_parse_type(&mut self) -> Option<ParseResult<RMType>> {
        parse_first!(self;
            try_parse_type_ident => |i| Ok(i),
            // TODO more complex types
        )
    }

    fn parse_ident_optionally_typed(&mut self) -> ParseResult<ASTOptionallyTypedIdent> {
        // TODO destructures
        let ident = self.ident()?;

        let ty = match self.parse_optional(|t| {
            t.try_separator(SeparatorType::Colon)?;
            t.try_parse_type()
        }) {
            Some(v) => Some(v?),
            None => None,
        };

        Ok(ASTOptionallyTypedIdent { ident, ty })
    }
    fn parse_ident_typed(&mut self) -> ParseResult<ASTTypedIdent> {
        // TODO destructures
        let ident = self.ident()?;

        self.separator(SeparatorType::Colon)?;
        let ty = match self.try_parse_type() {
            Some(v) => v?,
            None => Err(true)?,
        };

        Ok(ASTTypedIdent { ident, ty })
    }

    fn try_parse_var_declare_expr(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(|t| {
            let doc_comment = t.try_doc_comment();
            // match let and if successful, we are confident this is an assignment expression
            t.try_keyword(Keyword::VarDeclare)?;
            // do the rest
            Some(doc_comment)
        }, |t,doc_comment| {

                let ASTOptionallyTypedIdent { ident, ty } = t.parse_ident_optionally_typed()?;
                let writable = true; // TODO add immutable vars

                let initial_value = match t.parse_optional_result(|t| {
                    t.try_symbol(SLSymbol::Assign)
                },|t,_|{
                    t.parse_expr::</* allow range literal */ true, /* allow block postfixes */ true>()
                }) {
                    Some(initial_value) => {
                        Some(Box::new(initial_value?))
                    }
                    None => None
                };

                Ok(ASTExpression::VarDeclare { doc_comment, ident, writable, initial_value, ty })
        })
    }

    fn try_parse_var_assign_expr(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(|t| {
            let target = {
                // TODO advanced varaccessexpression
                let ident = t.try_ident()?;
                ASTVarAccessExpression::Var { ident }
            };
            let op = t.try_any_symbol()?.to_assignment_operator()?;
            Some((target, op))
        }, |t,(target,op)| {
            let value = Box::new(t.parse_expr::</* allow range literal */ true, /* allow block postfixes */ true>()?);
            Ok(ASTExpression::Assign { target, op, value })
        })
    }

    fn try_parse_trait_bounds(&mut self) -> Option<ParseResult<()>> {
        self.parse_optional_result(
            |t| t.try_separator(SeparatorType::Colon),
            |t, _| todo!("// TODO parse_template_def trait bound"),
        )
    }
    fn parse_template_def(&mut self) -> ParseResult<RMTemplateDef> {
        let ident = self.ident()?;
        let other_data = match self.try_parse_trait_bounds() {
            Some(t) => Some(t?),
            None => None,
        };
        return Ok(RMTemplateDef { ident });
        //
    }

    /// Parse a function definition.
    ///
    /// ```plaintext
    /// $( $doc_comment )? fn $fn_name
    ///     $( < $( $template_def ),+ > )?
    ///     ( $( $param ),* )
    ///     $( -> $ret_ty )?
    ///     $( = $fn_body )|( { $fn_body } )
    /// ````
    fn finish_parse_function_declaration(
        &mut self,
        doc_comment: DocComment,
        can_be_disembodied: bool,
        can_be_instance: bool,
    ) -> ParseResult<ASTFunctionDefinition> {
        let ident = self.ident()?;

        let local_template_defs = self
            .parse_optional_result(
                |t| t.try_symbol(SLSymbol::AngleOpen),
                |t, _| {
                    t.parse_until(
                        Self::parse_template_def,
                        SLToken::Separator(SeparatorType::Comma),
                        SLToken::Symbol(SLSymbol::AngleClose),
                        ParseDiagnostic::ExpectedSeparator(SeparatorType::Comma),
                    )
                },
            )
            .unwrap_or_else(|| Ok(vec![]))?;

        self.try_bracket_open(BracketType::Paren);
        let params = self.parse_until(
            |t| t.parse_ident_typed(),
            SLToken::Separator(SeparatorType::Comma),
            SLToken::BracketClose(BracketType::Paren),
            ParseDiagnostic::ExpectedSeparator(SeparatorType::Comma),
        )?;

        let return_ty = match self.parse_optional(|t| {
            t.try_separator(SeparatorType::ThinArrowRight);
            // TODO return type shorthands
            t.try_parse_type()
        }) {
            Some(v) => Some(v?),
            None => None,
        };

        let block = {
            let next = self.try_next();
            if matches!(next, Some(SLToken::BracketOpen(BracketType::Curly))) {
                // { ...
                Some(self.parse_block::</* not top-level */false>()?)
            } else if matches!(next, Some(SLToken::Symbol(SLSymbol::Assign))) {
                // = ...
                Some(vec![self.parse_expr::<
                    /* allow range literals */true,
                    /* allow block postfixes */true,
                >()?])
            } else {
                // t.rewind();
                // t.diagnostics.push(ParseDiagnostic::ExpectedFunctionBody);
                // return Err(true);
                None
            }
        };

        Ok(ASTFunctionDefinition {
            doc_comment,
            ident,
            params,
            return_ty,
            block,
            is_member: {
                eprintln!("// TODO is_member");
                can_be_instance
            },
            local_template_defs,
            can_be_disembodied,
        })
    }

    /// Parse a function definition (any context).
    ///
    /// ```plaintext
    /// $( $doc_comment )? fn $fn_name
    ///     $( < $( $template_def ),+ > )?
    ///     ( $( $param ),* )
    ///     $( -> $ret_ty )?
    ///     $( = $fn_body )|( { $fn_body } )
    /// ````
    fn try_parse_function_declaration(
        &mut self,
        can_be_disembodied: bool,
        can_be_instance: bool,
    ) -> Option<ParseResult<ASTFunctionDefinition>> {
        self.parse_optional_result(
            |t| {
                let doc_comment = t.try_doc_comment();
                t.try_keyword(Keyword::FunctionDefinition)?;
                Some(doc_comment)
            },
            |t, doc_comment| {
                Self::finish_parse_function_declaration(
                    t,
                    doc_comment,
                    can_be_disembodied,
                    can_be_instance,
                )
            },
        )
    }
    /// Parse a function that would appear as a stand-alone declaration.
    fn try_parse_top_level_function_declaration(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.try_parse_function_declaration(false, false)
            .map(|v| v.map(|v| ASTExpression::FunctionDefinition(v)))
    }

    fn try_parse_static_struct_declaration(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| {
                let doc_comment = t.try_doc_comment();
                t.try_keyword(Keyword::StructDefinition)?;
                Some(doc_comment)
            },
            |t, doc_comment| {
                let ident = t.ident()?;

                // TODO type parameters

                let mut properties = vec![];

                t.bracket_open(BracketType::Curly)?;

                while let Some(v) = t.parse_optional_result(
                    |t| {
                        let doc_comment = t.try_doc_comment();
                        let ident = t.try_ident()?;
                        Some((doc_comment, ident))
                    },
                    |t, (doc_comment, ident)| {
                        let ty = if t.try_separator(SeparatorType::Colon).is_some() {
                            Some(t.try_parse_type().unwrap_or_else(|| {
                                t.diagnostics.push(ParseDiagnostic::ExpectedTypeAnnotation);
                                Err(true)
                            })?)
                        } else {
                            t.diagnostics.push(ParseDiagnostic::ExpectedTypeAnnotation);
                            None
                        };

                        let initial = if t.try_symbol(SLSymbol::Assign).is_some() {
                            Some(t.parse_expr::</* allow range literal */true,/* allow block posfix */true>()?)
                        } else {
                            None
                        };
                        // TODO deal with initial 

                        let ty = ty.ok_or(true)?;
                        Ok((ident, doc_comment, ty))
                    },
                ) {
                    match v {
                        Ok(v) => properties.push(v),
                        Err(true) => continue,
                        Err(false) => return Err(false),
                    }
                }


                let mut impl_functions = HashMap::new();
                let mut impl_traits = HashMap::new();

                while !matches!(t.peek_next(), Some(SLToken::BracketClose(_))) {
                    // Unexpected end of input
                    if t.peek_next().is_none() {
                        t.diagnostics.push(ParseDiagnostic::UnexpectedEnd);
                        return Err(false);
                    }

                    // Simple function implementation
                    match t.try_parse_function_declaration(false, true) {
                        Some(Ok(func)) => {
                            impl_functions.entry(func.ident.clone()).and_modify(|_| {
                                t.diagnostics.push(ParseDiagnostic::DuplicateFunctions);
                            }).or_insert(func);
                            continue;
                        }
                        Some(Err(recoverable)) => if recoverable {
                            continue;
                        } else {
                            return Err(false);
                        }
                        None => {}
                    }

                    // Trait implementation
                    if t.try_keyword(Keyword::Implementation).is_some() {
                        todo!("// TODO struct definition trait implementation parsing")
                    }

                    // Unexpected token
                    t.diagnostics.push(ParseDiagnostic::ExpectedStructFunctions);
                    t.next()?;
                }
                t.bracket_close(BracketType::Curly)?;

                Ok(ASTExpression::StructDefinition {
                    doc_comment,
                    ident,
                    properties,
                    impl_functions,
                    impl_traits,
                })
            },
        )
    }
    fn try_parse_static_trait_declaration(&mut self) -> Option<ParseResult<ASTExpression>> {
        self.parse_optional_result(
            |t| {
                let doc_comment = t.try_doc_comment();
                t.try_keyword(Keyword::TraitDefinition)?;
                Some(doc_comment)
            },
            |t, doc_comment| {
                let ident = t.ident()?;
                // TODO template types in traits
                let bounds = match t.try_parse_trait_bounds() {
                    Some(v) => v?,
                    None => (),
                };

                let mut functions = HashMap::new();
                t.bracket_open(BracketType::Curly);
                while !matches!(
                    t.peek_next(),
                    Some(SLToken::BracketClose(BracketType::Curly)) | None
                ) {
                    todo!("// TODO parse trait function")
                }

                Ok(ASTExpression::TraitDefinition {
                    doc_comment,
                    ident,
                    bounds,
                    functions,
                })
            },
        )
    }
}

enum ExprAffix {
    Op(SLOperator),
    Compound(ASTCompoundPostfixContents),
}
/*

let a =

le t


*/
pub fn parse(tokens: Vec<SLToken>) -> (Result<ASTBlock, ()>, Vec<ParseDiagnostic>) {
    let mut parser = Tokens::new(&tokens);

    let block = parser.parse_block::<true>().map_err(|_| ());
    (block, parser.diagnostics)
}

#[cfg(test)]
mod test {
    use crate::parse::{
        ast::{ASTExpression, ASTLiteral},
        ops::SLOperator,
        parser::ParseDiagnostic,
        tokenization::{self, SLSymbol, SLToken, SeparatorType},
    };

    use super::{parse, Tokens};

    #[test]
    fn test_try_next() {
        let tokens = tokenization::SLTokenizer::new().tokenize("1+ \nabc: \n defg");
        let mut tokens = Tokens::new(&tokens);

        assert_eq!(
            tokens.try_next().copied(),
            Some(SLToken::Int {
                value: 1,
                imaginary: false
            })
        );
        assert_eq!(
            tokens.try_next().copied(),
            Some(SLToken::Symbol(SLSymbol::Plus))
        );
        assert_eq!(tokens.try_next().copied(), Some(SLToken::Identifier("abc")));
        assert_eq!(
            tokens.try_next().copied(),
            Some(SLToken::Separator(SeparatorType::Colon))
        );
        assert_eq!(
            tokens.try_next().copied(),
            Some(SLToken::Identifier("defg"))
        );
        assert_eq!(tokens.try_next(), None);
    }

    #[test]
    fn test_next() {
        let tokens = tokenization::SLTokenizer::new().tokenize("1+ \nabc: \n defg");
        let mut tokens = Tokens::new(&tokens);

        assert_eq!(
            tokens.next().copied(),
            Ok(SLToken::Int {
                value: 1,
                imaginary: false
            })
        );
        assert_eq!(tokens.next().copied(), Ok(SLToken::Symbol(SLSymbol::Plus)));
        assert_eq!(tokens.next().copied(), Ok(SLToken::Identifier("abc")));
        assert_eq!(
            tokens.next().copied(),
            Ok(SLToken::Separator(SeparatorType::Colon))
        );
        assert_eq!(tokens.next().copied(), Ok(SLToken::Identifier("defg")));
        assert_eq!(tokens.next(), Err(false));

        assert_eq!(
            &tokens.diagnostics[..],
            &[ParseDiagnostic::UnexpectedEnd][..]
        );
    }

    #[test]
    fn one_plus_one() {
        let tokens = tokenization::SLTokenizer::new().tokenize("1 + 1");

        assert_eq!(
            parse(tokens),
            (
                Ok(vec![ASTExpression::BinaryOp {
                    op: SLOperator::Plus,
                    lhs: Box::new(ASTExpression::Literal(ASTLiteral::Int(1))),
                    rhs: Box::new(ASTExpression::Literal(ASTLiteral::Int(1)))
                }]),
                vec![],
            )
        );
    }
}
